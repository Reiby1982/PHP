<?php
/*
Класс– это набор данных и методов, имеющих общую, целостную,
хорошо определенную сферу ответственности
Используется для хранения связанных свойств и методов
Свойства и методы называются членами класса.
*/

// создание класса:
class Human
{
    const TYPE = 'Человек'; // констата класса
    public $name; // свойство
    public $age; // свойство

    // Функция конструктор вызывается автоматически при создании объекта и выполняет инициализацию объекта
    function __construct($name)
    {
        // Псевдо-переменная $this доступна только в контексте объекта и является ссылкой на вызываемый объект
        $this->name = $name;
    }

    function speak($speech)
    {
//        Методы – это функции, объявленные внутри класса. Методы позволяют объектам выполнять задачи
        echo $this->name . " сказал: " . $speech . "<br>";
    }

    public function introduce() {
        echo "Меня зовут " . $this->name . ", мне " . $this->age . " лет <br>";
    }
}
/*
    На основе класса можно создавать его экземпляры - объекты
    Объекты – создаются на основе заранее определенных классов при помощи оператора new
    Для доступа к свойствам и методам объекта используется оператор '->'
*/
$human = new Human('Гриша');
$human->age = 19; // доступ к свойству
$human->speak('Привет!!!'); // доступ к методу
$human::TYPE; // доступ к константе
/*
На основе классов можно создавать не только объекты, но и другие классы.
Наследование - это механизм, позволяющий описать новый класс на
основе уже существующего (родительского, базового) класса

Класс, полученный в результате наследования, называют потомком или дочерним классом

Дочерний класс наследует все свойства и методы своего родителя
Дочерний класс расширяет функциональность родительского класса

В PHP для указания наследования в описании класса используется  ключевое слово  extends

Не поддерживает множественное наследование
*/


class Pupil extends Human { // Pupil (дочерний класс) отнаследовался от Human (родительский класс)
    const TYPE = 'Ученик';
    private $hobby;

    function __construct($name, $age, $hobby) // переопределение родительского конструктора
    {
        parent::__construct($name); // вызов родительского конструктора
        $this->age = $age; // расширение родительского конструктора
        $this->hobby = $hobby; // расширение родительского конструктора
    }

    public function introduce() { // переопределение метода родительского класса
        parent::introduce(); // доступ к методу!!! родительского класса
        echo "Мое хобби - " . $this->hobby . "<br>"; // расширили метод родительского класса
    }
}
$first_form = new Pupil('Вася', 7, 'Футбол');
$first_form->introduce(); // если метод родительского класса был переопределен в дочернем, вызывается метод дочернего класса
$first_form->speak('Не хочу в школу'); // имеет доступ к методу родительского класса


class School {
    private $max_pupil;
    private $name;
    private $pupils_list = [];

    function __construct($name, $max) {
        $this->name = $name;
        $this->max_pupil = $max;
    }

    function addPupil(Pupil $pupil) { // Pupil $pupil - указание типа данных - аргумент должен быть создан на основе указанного класса
        if ($this->max_pupil > count($this->pupils_list)) {
            $this->pupils_list[] = $pupil;
        } else {
            echo "В школе " . $this->name . "нет мест";
        }
    }

    function addManyPupils($pupils) {
        foreach ($pupils as $pupil) {
            if ($this->max_pupil > count($this->pupils_list)) {
                $this->pupils_list[] = $pupil;
            } else {
                echo "В школе " . $this->name . " нет мест для $pupil->name <br>";
            }
        }
    }

//Свойства и методы, к которым можно обратиться без создания объекта называются статическими.
//Объявляются с помощью ключевого слова static
//$this - в статическом методе использовать нельзя нельзя использовать!!!!
    public static function reportWeekend($days) {
        echo "Школа отдыхает $days дней<br>";
    }
}

$pupils = [
    new Pupil('Света', 7, 'Пианино'),
    new Pupil('Ваня', 7, 'Фехтование'),
    new Pupil('Женя', 6, 'Кино'),
    new Pupil('Катя', 7, 'Бокс'),
    new Pupil('Петя', 8, 'Прогулки'),
    new Pupil('Гоша', 7, 'Хокей')
];

$school = new School('№ 15', 4);
$school->addPupil($first_form);
$school->addManyPupils($pupils);
var_dump($school);

School::reportWeekend(15); // доступ к статическому методу (имя класса :: метод)
// для доступа к статическому методу нельзя использовать оператор ->

/*
модификаторы доступа:
указываются перед именем свойства (обязательно) и перед словом function (не обязательно, по умолчанию public)
PUBLIC – Открытый тип доступа. Разрешает доступ из любого контекста
PROTECTED – Защищенный тип доступа. Разрешает доступ только внутри класса и его потомков, но запрещает доступ извне.
PRIVATE – Закрытый тип доступа. Разрешает доступ только в пределах текущего класса

соответственно, если закрыть __construct он не сработает

с PHP >= 7.1.0 для констант можно задать модификатор доступа
*/

